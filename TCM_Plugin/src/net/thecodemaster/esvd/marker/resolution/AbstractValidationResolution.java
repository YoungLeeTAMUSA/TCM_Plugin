// package net.thecodemaster.esvd.marker.resolution;
//
// import java.util.ArrayList;
// import java.util.List;
//
// import net.thecodemaster.esvd.esapi.EsapiDependencyConfigurationJob;
// import net.thecodemaster.esvd.graph.BindingResolver;
// import net.thecodemaster.esvd.logger.PluginLogger;
// import net.thecodemaster.esvd.ui.view.ViewDataModel;
//
// import org.eclipse.core.resources.IMarker;
// import org.eclipse.core.resources.IProject;
// import org.eclipse.core.runtime.CoreException;
// import org.eclipse.jdt.core.ICompilationUnit;
// import org.eclipse.jdt.core.IJavaProject;
// import org.eclipse.jdt.core.JavaModelException;
// import org.eclipse.jdt.core.dom.AST;
// import org.eclipse.jdt.core.dom.ASTNode;
// import org.eclipse.jdt.core.dom.Block;
// import org.eclipse.jdt.core.dom.BooleanLiteral;
// import org.eclipse.jdt.core.dom.CatchClause;
// import org.eclipse.jdt.core.dom.CompilationUnit;
// import org.eclipse.jdt.core.dom.Expression;
// import org.eclipse.jdt.core.dom.ITypeBinding;
// import org.eclipse.jdt.core.dom.LineComment;
// import org.eclipse.jdt.core.dom.MethodDeclaration;
// import org.eclipse.jdt.core.dom.MethodInvocation;
// import org.eclipse.jdt.core.dom.NodeFinder;
// import org.eclipse.jdt.core.dom.NumberLiteral;
// import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
// import org.eclipse.jdt.core.dom.Statement;
// import org.eclipse.jdt.core.dom.StringLiteral;
// import org.eclipse.jdt.core.dom.TryStatement;
// import org.eclipse.jdt.core.dom.Type;
// import org.eclipse.jdt.core.dom.rewrite.ASTRewrite;
// import org.eclipse.jdt.core.dom.rewrite.ITrackedNodePosition;
// import org.eclipse.jdt.ui.JavaUI;
// import org.eclipse.jface.text.BadLocationException;
// import org.eclipse.jface.text.IDocument;
// import org.eclipse.text.edits.MalformedTreeException;
// import org.eclipse.text.edits.TextEdit;
// import org.eclipse.ui.IEditorInput;
// import org.eclipse.ui.IEditorPart;
//
// public abstract class AbstractValidationResolution extends AbstractResolution {
//
// // FIXME REMOVE THIS CONSTANTS FROM HERE
// private static final String ESAPI_IMPORT = "org.owasp.esapi.ESAPI";
// private static final String ESAPI_VALIDATION_EXCEPTION_IMPORT = "org.owasp.esapi.errors.IntrusionException";
// private static final String ESAPI_INTRUSION_EXCEPTION_IMPORT = "org.owasp.esapi.errors.ValidationException";
// private static final String ESAPI = "ESAPI";
// private static final String ESAPI_VALIDATOR = "validator";
// private static final String ESAPI_VALIDATOR_GETVALIDINPUT = "getValidInput";
// private static final String ESAPI_CONTEXT_PLACEHOLDER = "replace ME with validation context";
// private static final String ESAPI_TRY_COMMENT =
// "//  NOTE: try catch and validation code within was generated by ASIDE";
// private static final String ESAPI_COMMENT =
// "/* NOTE: If the following ASIDE generated code detects a problem \n * (e.g., malicious characters entered by user) an exception is thrown.\n * Doing so will skip the rest of the try block code and go directly to\n * (execute) one of the generated catch blocks below.\n * */ ";
// private static final String ESAPI_DEFAULT_LENGTH = "200"; // TODO
//
// public AbstractValidationResolution(int position, IMarker marker) {
// super(position, marker);
// }
//
// @Override
// public void run(IMarker marker) {
// try {
// // String returnTypeOfMethodDeclarationStr = (String) marker
// // .getAttribute("edu.uncc.sis.aside.marker.returnTypeOfMethodDeclarationBelongTo");
//
// List<ViewDataModel> vdms = getViewDataModelsFromMarker(marker);
// ViewDataModel vdm = vdms.get(0);
// Expression expression = vdm.getExpr();
// CompilationUnit cUnit = BindingResolver.getCompilationUnit(expression);
//
// int offset = marker.getAttribute(IMarker.CHAR_START, -1);
// int length = marker.getAttribute(IMarker.CHAR_END, -1) - offset;
//
// IEditorPart part = JavaUI.openInEditor(cUnit.getJavaElement(), true, true);
// IEditorInput input = part.getEditorInput();
// IDocument document = JavaUI.getDocumentProvider().getDocument(input);
//
// // TODO CHECK IF THIS LINE BELOW IS NECESSARY
// // ASIDEMarkerAndAnnotationUtil.deleteMarkerAtPosition(marker);
//
// generateSpecialOutputValidationCode(cUnit, document, offset, length);
// insertImport(cUnit, document, ESAPI_IMPORT);
//
// IJavaProject javaProject = cUnit.getJavaElement().getJavaProject();
// IProject project = javaProject.getProject();
//
// EsapiDependencyConfigurationJob job = new EsapiDependencyConfigurationJob("ESAPI Configuration", project,
// javaProject);
//
// job.scheduleInteractive();
// } catch (MalformedTreeException | BadLocationException | CoreException e) {
// PluginLogger.logError(e);
// }
// }
//
// private boolean generateSpecialOutputValidationCode(CompilationUnit cUnit, IDocument document, int offset, int
// length)
// throws MalformedTreeException, BadLocationException, JavaModelException, IllegalArgumentException {
//
// ASTNode node = NodeFinder.perform(cUnit, offset, length);
// MethodDeclaration declaration = BindingResolver.getParentMethodDeclaration(node);
// Block body = declaration.getBody();
// AST ast = body.getAST();
//
// int hasGeneratedWhichException = 0;
//
// ICompilationUnit fCompilationUnit = (ICompilationUnit) cUnit.getJavaElement();
// int tmpOffset = 0;
//
// int returnStartPosition = 0;
// int returnLength = 0;
// String esapiComment = "";
// ITrackedNodePosition replacementPositionTracking = null;
// if (node instanceof MethodInvocation) {
// int inWhichExceptionFlag = inWhichExceptionTryCatch((MethodInvocation) node);
// if (inWhichExceptionFlag != 1)
// esapiComment =
// "/* NOTE: If the following ASIDE generated code detects a problem \n * (e.g., malicious characters entered by user)"
// +
// " an exception is thrown.\n * Doing so will skip the rest of the try block code and go directly to\n * (execute) one of the "
// + "generated catch blocks below.\n * */ \n";
// else
// esapiComment = "// NOTE: code generated by ASIDE\n                   ";
// }
//
// replacementPositionTracking = generateSpecialOutputValidationRoutine(cUnit, document, node);
//
// CompilationUnit newestAstRoot = BindingResolver.parse(fCompilationUnit);
// ASTNode theEsapiNode = NodeFinder.perform(newestAstRoot, replacementPositionTracking.getStartPosition(),
// replacementPositionTracking.getLength());
//
// Statement statementBelongTo = BindingResolver.getParentStatement(theEsapiNode);
// tmpOffset = statementBelongTo.getStartPosition();
//
// document.replace(tmpOffset, 0, esapiComment);
// int esapiCommentLength = esapiComment.length();
//
// CompilationUnit newAstRoot = BindingResolver.parse(fCompilationUnit);
// ASTNode esapiNode = NodeFinder.perform(newAstRoot, theEsapiNode.getStartPosition() + esapiCommentLength,
// theEsapiNode.getLength());
//
// ASTRewriteAndTracking astRewriteAndTracking;
// ITrackedNodePosition validationReturnPostion;
// ITrackedNodePosition intrusionReturnPosition;
// Statement tmpStatement = BindingResolver.getParentStatement(esapiNode);
//
// int inWhichException = 2;
//
// if (esapiNode instanceof MethodInvocation)
// inWhichException = inWhichExceptionTryCatch((MethodInvocation) esapiNode);
// if (inWhichException == 0)
// hasGeneratedWhichException = 1;
// else if (inWhichException == 2)
// hasGeneratedWhichException = 2;
// else if (inWhichException == 3)
// hasGeneratedWhichException = 3;
// if (inWhichException != 1) {
// // ASIDEMarkerAndAnnotationUtil.removeAnnotationAtPosition(fCompilationUnit, esapiNode);
//
// AST secondAst = newAstRoot.getAST();
// ASTRewrite secondfASTRewrite = ASTRewrite.create(secondAst);
//
// astRewriteAndTracking = generateTry(document, fCompilationUnit, secondfASTRewrite, secondAst, inputType,
// esapiNode, returnTypeOfMethodDeclarationStr, hasGeneratedWhichException);
//
// validationReturnPostion = astRewriteAndTracking.getFirstNodePosition();
// intrusionReturnPosition = astRewriteAndTracking.getSecondNodePosition();
//
// if (hasGeneratedWhichException == 1 || hasGeneratedWhichException == 2) {
// returnStartPosition = validationReturnPostion.getStartPosition();
// returnLength = validationReturnPostion.getLength();
// } else if (hasGeneratedWhichException == 3) {
// returnStartPosition = intrusionReturnPosition.getStartPosition();
// returnLength = intrusionReturnPosition.getLength();
// }
//
// }
//
// boolean hasInsertCommentForCatchReturn = false;
// if (hasGeneratedWhichException == 1 || hasGeneratedWhichException == 2 || hasGeneratedWhichException == 3)
// hasInsertCommentForCatchReturn = insertCommentForCatchReturn(fCompilationUnit, returnStartPosition, returnLength,
// hasGeneratedWhichException);
//
// List<String> listImport = new ArrayList<String>();
// listImport.add(ESAPI_IMPORT);
// listImport.add(ESAPI_VALIDATION_EXCEPTION_IMPORT);
// listImport.add(ESAPI_INTRUSION_EXCEPTION_IMPORT);
// insertImport(cUnit, document, listImport);
//
// return true;
// }
//
// public ITrackedNodePosition generateSpecialOutputValidationRoutine(CompilationUnit cUnit, IDocument document,
// ASTNode node) throws IllegalArgumentException, CoreException, MalformedTreeException, BadLocationException {
//
// // ###################
// // Statement statement = ASTResolving.findParentStatement(node);
// ASTRewrite astRewrite = ASTRewrite.create(ast);
// // ###################
//
// MethodInvocation esapiValidator = ast.newMethodInvocation();
// esapiValidator.setExpression(ast.newSimpleName(ESAPI));
// esapiValidator.setName(ast.newSimpleName(ESAPI_VALIDATOR));
//
// MethodInvocation esapiValidation = ast.newMethodInvocation();
// esapiValidation.setExpression(esapiValidator);
// esapiValidation.setName(ast.newSimpleName(ESAPI_VALIDATOR_GETVALIDINPUT));
//
// List<ASTNode> arguments = esapiValidation.arguments();
//
// StringLiteral contextArg = ast.newStringLiteral();
// contextArg.setLiteralValue(ESAPI_CONTEXT_PLACEHOLDER);
// arguments.add(0, contextArg);
//
// arguments.add(1, fASTRewrite.createCopyTarget(node));
//
// StringLiteral inputTypeArg = ast.newStringLiteral();
// inputTypeArg.setLiteralValue(inputType);
// arguments.add(2, inputTypeArg);
//
// NumberLiteral lengthArg = ast.newNumberLiteral(ESAPI_DEFAULT_LENGTH);
// arguments.add(3, lengthArg);
//
// BooleanLiteral allowNullArg = ast.newBooleanLiteral(false);
// arguments.add(4, allowNullArg);
//
// LineComment notice = (LineComment) fASTRewrite.createStringPlaceholder(ESAPI_COMMENT, ASTNode.LINE_COMMENT);
//
// MethodDeclaration methodToBeReplaced = ASTResolving.findParentMethodDeclaration(statement);
//
// fASTRewrite.replace(node, esapiValidation, null);
//
// TextEdit textEdits = null;
// textEdits = fASTRewrite.rewriteAST();
// textEdits.apply(document, TextEdit.CREATE_UNDO | TextEdit.UPDATE_REGIONS);
//
// ITrackedNodePosition replacementPositionTracking = fASTRewrite.track(esapiValidation);
// return replacementPositionTracking;
// }
//
// private int inWhichExceptionTryCatch(MethodInvocation targetNode) {
// Statement targetStatement = null;
// targetStatement = ASTResolving.findParentTryStatement(targetNode);
// int result = 0;
// boolean hasValidationException = false;
// boolean hasIntrusionException = false;
//
// while (targetStatement != null && targetStatement instanceof TryStatement) {
// result = isWhichTypeExceptionTryCatch((TryStatement) targetStatement);
// if (result == 1) {
// return 1;
// } else if (result == 2) {
// hasIntrusionException = true;
// } else if (result == 3) {
// hasValidationException = true;
// }
// targetStatement = ASTResolving.findParentTryStatement(targetStatement);
// }
//
// if (hasValidationException == true && hasIntrusionException == true)
// return 1;
// else if (hasIntrusionException == true)
// return 2;
// else if (hasValidationException == true)
// return 3;
// else
// return 0;
// }
//
// private int isWhichTypeExceptionTryCatch(TryStatement targetStatement) {
// if (targetStatement == null)
// return 0;
// else if (targetStatement instanceof TryStatement) {
//
// TryStatement targetTryStatement = targetStatement;
// List<CatchClause> catchList = targetTryStatement.catchClauses();
// if (catchList.size() < 1) {
// System.out.println("catchList.size() < 1 in isWhichTypeExceptionTryCatch");
// return 0;
// } else if (catchList.size() == 1) {
// CatchClause clause = catchList.get(0);
// SingleVariableDeclaration exception = clause.getException();
// Type type = exception.getType();
// ITypeBinding binding = type.resolveBinding();
// if (binding != null) {
// String qualifiedName = binding.getQualifiedName();
// if (qualifiedName.equals("java.lang.Exception")) {
// return 1;
// } else if (qualifiedName.equals("java.lang.RuntimeException")) {
// return 2;
// } else if (qualifiedName.equals("org.owasp.esapi.errors.IntrusionException")) {
// return 2;
// } else if (qualifiedName.equals("org.owasp.esapi.errors.ValidationException")) {
// return 3;
// }
// }
// } else if (catchList.size() >= 2) {
// boolean isException = false;
// boolean isRuntimeException = false;
// boolean isValidationException = false;
// boolean isIntrusionException = false;
// for (int i = 0; i < catchList.size(); i++) {
// CatchClause clause = catchList.get(i);
// SingleVariableDeclaration exception = clause.getException();
// Type type = exception.getType();
// ITypeBinding binding = type.resolveBinding();
// if (binding != null) {
// String qualifiedName = binding.getQualifiedName();
// if (qualifiedName.equals("java.lang.Exception")) {
// isException = true;
// } else if (qualifiedName.equals("java.lang.RuntimeException")) {
// isRuntimeException = true;
// } else if (qualifiedName.equals("org.owasp.esapi.errors.ValidationException")) {
// isValidationException = true;
// } else if (qualifiedName.equals("org.owasp.esapi.errors.IntrusionException")) {
// isIntrusionException = true;
// }
// }
// }
// if (isException == true) {
// return 1;
// } else if (isValidationException == true) {
// if (isRuntimeException == true || isIntrusionException == true)
// return 1;
// else
// return 3;
// } else if (isRuntimeException == true || isIntrusionException == true) {
// return 2;
// }
// }
// } else {
// return 0;
// }
// return 0;
// }
// }
